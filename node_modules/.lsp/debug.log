Hello - from c:\Users\Maja\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\Maja\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///c%3A/Programiranje1/domaca-naloga/solver.ml","languageId":"ocaml","version":1,"text":"type available = { loc : int * int; possible : int list }\r\n\r\n(* TODO: tip stanja ustrezno popravite, saj boste med reševanjem zaradi učinkovitosti\r\n   želeli imeti še kakšno dodatno informacijo *)\r\ntype state = { problem : Model.problem; current_grid : int option Model.grid }\r\n\r\nlet print_state (state : state) : unit =\r\n  Model.print_grid\r\n    (function None -> \"?\" | Some digit -> string_of_int digit)\r\n    state.current_grid\r\n\r\ntype response = Solved of Model.solution | Unsolved of state | Fail of state\r\n\r\nlet initialize_state (problem : Model.problem) : state =\r\n  { current_grid = Model.copy_grid problem.initial_grid; problem }\r\n\r\nlet validate_state (state : state) : response =\r\n  let unsolved =\r\n    Array.exists (Array.exists Option.is_none) state.current_grid\r\n  in\r\n  if unsolved then Unsolved state\r\n  else\r\n    (* Option.get ne bo sprožil izjeme, ker so vse vrednosti v mreži oblike Some x *)\r\n    let solution = Model.map_grid Option.get state.current_grid in\r\n    if Model.is_valid_solution state.problem solution then Solved solution\r\n    else Fail state\r\n\r\nlet branch_state (state : state) : (state * state) option =\r\n  (* TODO: Pripravite funkcijo, ki v trenutnem stanju poišče hipotezo, glede katere\r\n     se je treba odločiti. Če ta obstaja, stanje razveji na dve stanji:\r\n     v prvem predpostavi, da hipoteza velja, v drugem pa ravno obratno.\r\n     Če bo vaš algoritem najprej poizkusil prvo možnost, vam morda pri drugi\r\n     za začetek ni treba zapravljati preveč časa, saj ne bo nujno prišla v poštev. *)\r\n  failwith \"TODO\"\r\n\r\n(* pogledamo, če trenutno stanje vodi do rešitve *)\r\nlet rec solve_state (state : state) =\r\n  (* uveljavimo trenutne omejitve in pogledamo, kam smo prišli *)\r\n  (* TODO: na tej točki je stanje smiselno počistiti in zožiti možne rešitve *)\r\n  match validate_state state with\r\n  | Solved solution ->\r\n      (* če smo našli rešitev, končamo *)\r\n      Some solution\r\n  | Fail fail ->\r\n      (* prav tako končamo, če smo odkrili, da rešitev ni *)\r\n      None\r\n  | Unsolved state' ->\r\n      (* če še nismo končali, raziščemo stanje, v katerem smo končali *)\r\n      explore_state state'\r\n\r\nand explore_state (state : state) =\r\n  (* pri raziskovanju najprej pogledamo, ali lahko trenutno stanje razvejimo *)\r\n  match branch_state state with\r\n  | None ->\r\n      (* če stanja ne moremo razvejiti, ga ne moremo raziskati *)\r\n      None\r\n  | Some (st1, st2) -> (\r\n      (* če stanje lahko razvejimo na dve možnosti, poizkusimo prvo *)\r\n      match solve_state st1 with\r\n      | Some solution ->\r\n          (* če prva možnost vodi do rešitve, do nje vodi tudi prvotno stanje *)\r\n          Some solution\r\n      | None ->\r\n          (* če prva možnost ne vodi do rešitve, raziščemo še drugo možnost *)\r\n          solve_state st2 )\r\n\r\nlet solve_problem (problem : Model.problem) =\r\n  problem |> initialize_state |> solve_state\r\n"}}}
